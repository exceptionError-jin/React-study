

ReactJS ?
    복잡한 사용자 인터페이스(UI)를 쉽게 구축하기 위해 페이스북팀에서 제작한 자바스크립트 기반 라이브러리

ReactJS의 구동원리와 핵심 컨셉
    
    Components
        - 한 가지 이상의 기능을 수행하는 UI 단위로 분리한 페이지의 조각
        - 재사용이 용이하고 유지 보수에 효율적

    Virtual DOM
        - React가 가지고 있는 가상 돔, 돔의 복사본
        - state(상태)의 변화를 react에서 감지하고 있으며 state의 변화가 생긴다면
        해당 state를 가지고 있는 Components의 가상돔과 실제 돔을 비교하여 변화가 생긴 Components만 리랜더

    
    KeyPoint
        state(상태)
        Components(UI 분리)
        Virtual DOM(가상돔 - state 변화 - 감지 - 비교 - 리랜더)

    --------------------------------------------------------------------------

    CSR, SSR
    * 주체 

        CSR (Client Side Rendering)
            장점
                페이지에 필요한 리소스를 전부 사전에 불러와 데이터를 캐싱하고 있다가
                현재 URL에 맞는 페이지를 보여주기 때문에 초기 랜더링 이후 속도가 빠르다


            단점
                초기 페이지 로딩이 SSR보다 느립니다 => 모든 리소스
                
                SEO(검색 엔진 최적화)에 불리 => 빈 화면
                
                백엔드에서 데이터를 받아오는 동안 사용자가 빈 리소스를 보게될 가능성이 큼
                => ex) 사용자가 페이지 로드 시 비어있는 상품 이미지를 보게된다.


        SSR (Sever Side Rendering)
            장점
                SEO에 유리 => 서버에서 완성된 페이지 전달, 검색 엔진이 수집하기 용이
                서버에서 랜더링을 부담하기 때문에 사용자 하드웨어 의존 x

            단점
                서버의 부담 (생산 비용 증가)
                SSR을 위한 코드 작성 필요 (생산 비용 증가, 추가 러닝 커브)
                무거운 페이지라고 한다면 초기 로딩이 오히려 CSR보다 오래 걸리 수 있음

        KeyPoint
            - 페이지를 완성하는 주체가 누구인지 (Client, Server)
            - 빈 화면, 완성된 화면
            - 캐싱, 재요청

     --------------------------------------------------------------------------  
        
    SPA, MPA

        SPA (Single Page Application)
            html 파일이 하나인 애플리케이션

            reactJS와 같이 컴포넌트 기반 라이브러리 및 프레임워크는 SPA에 최적화
            사용자가 웹 사이트 접속 당시 번들링 된 리소스들을 한번에 전달

            URL이 변경 됨에 따라 html을 해당 URL에 맞는 리소스를 랜더링한다

            따라서 통상적으로 react의 파일 구조는 index.html 하나로만 구성되어있다

        MPA (Multi Page Application)
            html 파일이 여러개인 애플리케이션
            요청 마다 해당 페이지에 필요한 리소스를 불러와 화면을 랜더링한다

        KeyPoint
            페이지 개 수
            SPA -> URL

     --------------------------------------------------------------------------  

        React는 CSR, SPA에 최적화

     --------------------------------------------------------------------------

        패키지 관리툴
            라이브러리들을 관리하고 설치할 수 있는 도구
            npm, npx, yarn, yarn2,3(yarn berry)


        * npm
            node에서 기본적으로 내장 되어있는 패키지 관리 툴
            ex)
            npm i(install) 라이브러리명 -- 설치
            npm rm(remove) 라이브러리명 -- 삭제

            npm i -g 라이브러리명 (노드 환경에 자체에 설치)
            npm i -D 라이브러리명 (개발자 환경에서 설치)


        * npx
            npm과 달리 설치하지 않고 라이브러리를 실행 시켜주는 도구
            npm과 마찬가지로 node5.2버전 이상부터 기본 내장

            일회성으로 무거운 패키지를 설치해야할 때
            ex) npx create-react-app 프로젝트명

        npm - 설치하는 명령어
        npx - 설치하지 않고 실행시키는 명령어

        * yarn
            과거에는 npm보다 속도, 안정성, 보안 모두 뛰어나서 이목을 끌었지만
            현재는 거의 차이가 없습니다.
            
        * yarn berry
            npm과 yarn의 경우는 설치된 라이브러리를 node_modules라는 파일로 관리
            pnp라는 방식을 도입 zero install
            .zip 파일을 관리하기 때문에 프로젝트 자체가 가볍고 빌드 속도가 빠릅니다.

            ** 모노레포
            하나의 워크스페이스에 여러 프로젝트를 담고 관리

            그러나, 다른 프로젝트를 한페이지 담고 관리한다는 것은 폴더 구조나 신경을
            써야하는 부분들이 배로 늘어난다는 이야기 따라서 초기에 적용하는 것은 좋지
            않고 이미 사용자가 충분히 확보된 복잡한 프로젝트를 간단하게 만들기 위해 사용

     --------------------------------------------------------------------------

        리엑트 프로젝트 생성
            
            1. 터미널 명령어를 통해 내가 프로젝트를 생성하고자 하는 위치에 경로 맞춰야함
            2. 리엑트 프로젝트 생성 명령어
                cra(create-react-app)

                vite esBuild<-- 입문자가 사용하기에는 적합하지 않음
                CRA가 익숙해지면 vite를 사용

                cra는 react에 필요한 모든 설정을 대신 설정(웹팩,바벨,env... )
                이미 설치된 도구를 커스텀하기 힘들다

            3. npx create-react-app 프로젝트명(ex1)
               - npx create-react-app ex1

     --------------------------------------------------------------------------

        webpack(모듈 번들러), babel          

        * webpack
            모듈 번들러

                모듈 -> 한가지 이상의 기능을 하는 분리된 코드의 집합
                번들러 -> 묶어주고 정리하는 것

                html, css ,js , media
                너저분하게 관리되어있는 리소스들을 확장자명이나 특정 기준으로
                분류하여 묶어주는 역할

                웹팩은 이런 모듈 번들로의 일종으로 CSR 특성 상 URL에 따라 해당
                페이지의 리소스를 찾아와 보여주어야 하는데 이러한 탐색 시간을 줄여

                네트워크 연산 비용을 줄일 수 있음

                1. 모듈 단위의 개발
                2. loader를 통해 js가 로드 할 수 없는 파일도 로드할 수 있는 상태로 변환

        * babel
                트랜스파일러

                최신 문법들을 이해하지 못하는 하위 버전의 웹 브라우저 로더들이
                최신 문법을 이해할 수 있도록 저레벨의 문법으로 트랜스 파일하여 변환

                ES6(ES2015)
                ES-NEXT(2020 이후) --- 이해 못하는 브라우저 --> 이해 가능하도록 변환

                * react에서 사용중인 babel은 총 4종류

                    1. @babel/core --- 바벨을 구동시키기 위한 핵심 요소
                    2. @babel/cli ---- 쉘에서 바벨 명령어 사용 가능
                    3. @babel/preset-env ---- 바벨의 가장 기본 설정 
                    4. @bable/preset-react ---- 바벨을 JSX문법(react문법)을 이해할 수 있도록

     --------------------------------------------------------------------------

     리엑트 프로젝트 구조
                .git
                node_moduels - 현재 프로젝트에 설치된 라이브러리의 파일
                               용량이 높은 편, gitignore에 들어가 있음
                               따라서 github으로 프로젝트를 다운로드 받으면 반드시
                               npm i <--라는 명령어를 사용

                               * npm i, package.json에 등록된 모든 라이브러리를 설치


                public       - 정적 파일 보관소 (index.html, favicon, robots)
                ** src       - source, 실제 개발이 이루어지는 폴더
                .gitignore   
                package.json  - 설치된 라이브러리 버전 및 목록 관리, 실행 스크립트(명령어)
                package-lock.json - 라이브의 실제 설치 주소와 버전을 관리
                READMD.md
            
     --------------------------------------------------------------------------

                src의 구조
                    App.css
                        app.js에 참조되어있는 기본 css파일
                        - indx.js와 app.js는 react 구조 상 가장 최상위 컴포넌트
                        - app.css는 모든 컴포넌트에 적용되는 전역 css 파일

                        - 그러나 현재 실무에서 가장 많이 사용되는 것은
                        - 일반적인 css보다는 css-in-js가 더 많습니다.
                        - 이 경우는 app.css가 필요 없어짐
                        - +1 그러나, 현재 가장 주목 받고있는 것은 css-in-js가 아님


                    App.js
                        - routing (주소 설정, 주소에 맞는 리소스를 보여줌)
                        - 라이브러리의 기본 설정 (provider, root ... )
                        - 최상위 컴포넌트 중 하나
                        
                    App.test.js
                        - test 코드의 샘플

                    index.css
                        - app.css와 동일
                        - 컴포넌트 조립 페이지화 -> 라우팅 설정 -> app.js -> index.js
                          -> public/index.html 

                    index.js
                        - 최상위 컴포넌트

                    reportWebVitals.js
                        - 프론트 엔드 성능 체크 (x)

                    setipTests.js
                        - testcode 작성을 위한 전역 참조 설정

-------------------------------------------------------------------------------------
